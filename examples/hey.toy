
fun squared(n) { n * n }
fun sqrt(x) { x ** 0.5 } 

fun isPrime(n) {
    if n < 2 { return false }
    if n == 2 { return true }
    if n mod 2 == 0 { return false }

    mut i = 3

    while squared(i) <= n {
        if n mod i == 0 {
            return false
        }

        i += 2
    }

    true
}

fun primes(count) {
    mut primes = [2]
    mut i = 3

    while len(primes) < count {
        if isPrime(i) {
            append(primes, i)
        }
        
        i += 2
    }

    primes
}

fun sum(elems) {
    mut total = 0

    for n in elems {
        total = total + n
    }

    total
}

fun map(elems, f) {
    mut mapped = []

    for elem in elems {
        append(mapped, f(elem))
    }

    mapped
}

fun filter(elems, f) {
    mut filtered = []

    for elem in elems {
        if f(elem) {
            append(filtered, elem)
        }
    }

    filtered
}

fun any(elems, f) {
    for elem in elems {
        if f(elem) {
            return true
        }
    }

    false
}

fun all(elems, f) {
    for elem in elems {
        if !f(elem) {
            return false
        }
    }

    true
}

fun chars(str) {
    mut characters = []
    mut i = 0
    mut length = len(str)

    while i < length {
        append(characters, charAt(str, i))
        i += 1
    }

    characters
}

fun hash(str, n) {
    mut h = 0
    mut length = len(str)
    mut i = 0

    while i < length {
        h = (h + 31 * charCodeAt(str, i)) mod n
        i += 1
    }

    h
}

fun range(n) {
    mut i = 0
    mut rng = []

    while i < n {
        append(rng, i)
        i += 1
    }

    rng
}

fun findIndex(elems, f) {
    mut i = 0
    let length = len(elems)

    while i < length {
        if f(elems[i]) {
            return i
        }

        i += 1
    }

    -1
}

fun hashMake(n) {
    mut buckets = []
    mut i = 0

    while i < n {
        append(buckets, [])
        i += 1
    }

    buckets
}

fun hashKeyLocation(h, key) {
    let n = len(h)
    let idx = hash(key, n)
    mut bucket = h[idx]
    let entryIdx = findIndex(bucket, fun(entry) entry.0 == key)
    (bucket, entryIdx)
}

fun hashSet(h, key, value) {
    let loc = hashKeyLocation(h, key)
    let bucket = loc.0
    let entryIdx = loc.1
    
    if entryIdx >= 0 {
        bucket[entryIdx] = (key, value)
    } else {
        append(bucket, (key, value))
    }
}

fun hashGet(h, key) {
    let loc = hashKeyLocation(h, key)
    let bucket = loc.0
    let entryIdx = loc.1

    if entryIdx == -1 {
        panic("hashGet: key '" ++ key ++ "' not found")
    }

    bucket[entryIdx].1
}

fun hashHas(h, key) {
    hashKeyLocation(h, key).1 != -1   
}

fun hashEntries(h) {
    mut entries = []
    
    for bucket in h {
        for entry in bucket {
            append(entries, entry)
        }
    }

    entries
}

fun hashKeys(h) {
    map(hashEntries(h), fun(entry) entry.0)
}

fun hashValues(h) {
    map(hashEntries(h), fun(entry) entry.1)
}

mut population = hashMake(10)
hashSet(population, "Gueberschwihr", 838)
hashSet(population, "Eguisheim", 1734)
hashSet(population, "Colmar", 70284)
hashSet(population, "Troyes", 60928)
hashSet(population, "Paris", 2102650)
print(population)
